#version 450
layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outputImage;
layout(push_constant) uniform Push { float time; } pc;

float sdSphere(vec3 p, float r) { return length(p) - r; }

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float scene(vec3 p) {
    float sphere = sdSphere(p - vec3(0.0, 0.3 * sin(pc.time * 2.0), 0.0), 0.8);
    float box    = sdBox(p - vec3(0.0, -0.8, 0.0), vec3(2.0, 0.1, 2.0));
    return min(sphere, box);
}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        scene(p + e.xyy) - scene(p - e.xyy),
        scene(p + e.yxy) - scene(p - e.yxy),
        scene(p + e.yyx) - scene(p - e.yyx)));
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pos.x >= size.x || pos.y >= size.y) return;

    // Remap to [-1,1] with correct aspect ratio.
    vec2 uv = (2.0 * vec2(pos) - vec2(size)) / float(size.y);

    // Camera orbiting the scene.
    float ca = pc.time * 0.5;
    vec3 ro = vec3(3.0 * sin(ca), 1.5, 3.0 * cos(ca));
    vec3 ta = vec3(0.0);
    vec3 ww = normalize(ta - ro);
    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
    vec3 vv = cross(uu, ww);
    vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.0 * ww);

    // Sphere-tracing raymarcher.
    float t = 0.0;
    vec3 col = vec3(0.05, 0.05, 0.1);
    for (int i = 0; i < 100; ++i) {
        vec3 p = ro + t * rd;
        float d = scene(p);
        if (d < 0.001) {
            vec3 n     = calcNormal(p);
            vec3 light = normalize(vec3(1.0, 2.0, 3.0));
            float diff = max(dot(n, light), 0.0);
            float amb  = 0.15;
            // Material: sphere is warm red, floor is cool grey.
            vec3 matCol = (p.y < -0.65) ? vec3(0.4, 0.4, 0.5) : vec3(0.8, 0.3, 0.2);
            col = matCol * (diff + amb);
            // Soft shadow ray toward the light.
            float sh = 1.0;
            vec3  sp = p + n * 0.01;
            float st = 0.01;
            for (int j = 0; j < 40; ++j) {
                float sd = scene(sp + light * st);
                sh = min(sh, 8.0 * sd / st);
                st += sd;
                if (sd < 0.001 || st > 5.0) break;
            }
            col *= 0.3 + 0.7 * clamp(sh, 0.0, 1.0);
            break;
        }
        t += d;
        if (t > 20.0) break;
    }

    // Gamma correction (sRGB approximation).
    col = pow(col, vec3(0.4545));
    imageStore(outputImage, pos, vec4(col, 1.0));
}
